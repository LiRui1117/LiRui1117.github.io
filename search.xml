<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kafka环境搭建]]></title>
    <url>%2F2019%2F07%2F10%2Fkafka%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[​ Kafka环境搭建 ​ 官网 Zookeeper首先要在Linux系统下安装java环境 1.下载zookeeper到zookeeper官网下载 2.配置zookeeper·利用Xftp将压缩包上传至Linux系统中，解压tar -zxvf zookeeper-3.4.13.tar.gz ·进入conf目录：cd zookeeper-3.4.13/conf ·将zoo_sample.cfg这个文件复制为zoo.cfg (必须是这个文件名cp zoo_sample.cfg zoo.cfg 3.启动zookeeper·进入bin目录，并启动zookeeper 注意： ./zkServer.sh start前面的.不可忽略。 cd/zookeeper-3.4.13/bin ./zkServer.sh start ·启动成功效果如下： ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg Starting zookeeper … STARTED Kafka1. Kafka下载官网下载 2. Kafka配置·利用Xftp将压缩包上传至Linux系统中，解压​ tar -zxvf kafka_2.12-2.3.0 ·配置Kafka文件（不配置也能在本地机上执行，不配置默认主机是localhost ，后期写linux的ip地址） ·启动Kafkacd进入Kafka解压目录，输入 bin/kafka-server-start.sh config/server.properties 3. Producer和Counsumer·创建一个topic在Kafka解压目录打开终端，输入 bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test 创建一个名为test的topic 在创建topic后可以通过输入 bin/kafka-topics.sh –list –zookeeper localhost:2181 来查看已经创建的topic ·创建一个消息消费者（Counsumer）在Kafka解压目录打开终端，输入 bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning 可以创建一个用于消费topic为test的消费者 消费者创建完成之后，因为还没有发送任何数据，这里在执行后没有打印出任何数据 ·创建一个消息生产者（Producer）在Kafka解压目录打开一个新的终端，输入 bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test 在执行完毕后会进入的编辑器页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[雪花算法]]></title>
    <url>%2F2019%2F07%2F10%2F%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ snowflake 雪花算法简单描述： 最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 看的出来，这个算法很简洁也很简单，但依旧是一个很好的ID生成策略。其中，10位器标识符一般是5位IDC+5位machine编号，唯一确定一台机器。 Snowflake算法核心把时间戳，工作机器id，序列号组合在一起。 整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;/**- &lt;p&gt;名称：IdWorker.java&lt;/p&gt;- &lt;p&gt;描述：分布式自增长ID&lt;/p&gt;- &lt;pre&gt;- Twitter的 Snowflake JAVA实现方案- &lt;/pre&gt;- 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用：- 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000- 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，- 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），- 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。- 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），- 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。- &lt;p&gt;- 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) *- @author Polim */ public class IdWorker &#123; // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker()&#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** - @param workerId - 工作机器ID - @param datacenterId - 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** - 获取下一个ID * - @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** - &lt;p&gt; - 获取 maxWorkerId - &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* - GET jvmPid */ mpid.append(name.split("@")[0]); &#125; /* - MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** - &lt;p&gt; - 数据标识id部分 - &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(" getDatacenterId: " + e.getMessage()); &#125; return id; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2019%2F06%2F02%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ Markdown的语法 ​ 语法文档 字体颜色，大小设置12345678&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=72 face=”黑体”color=#00ffffcolor=gray Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 颜色表 设置图片展示比例1&lt;img src="快捷键/wallhaven-374651123.png" width="50%" height="50%"&gt; Next主题的内置标签文本居中的引用 此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。 12345&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 效果弱者只有千难万难，而勇者则能披荆斩棘;愚者只有声声哀叹，智者却有千路万路。 一帆风顺的人，往往经受不住挫折。 凡事要主动出击你才能成为主角，否则你只能是配角! Bootstrap Callout使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger 效果从上到下 一切利己的生活，都是非理性的，动物的生活。——列夫·托尔斯泰 受苦的人，没有悲观的权利。——尼采 越学习，越发现自己的无知。——笛卡尔 社会是一个泥坑，我们得站在高地上。——巴尔扎克 生命不等于是呼吸，生命是活动。——卢梭 人生不是一种享乐，而是一桩十分沉重的工作。——列夫·托尔斯泰 标题标准语法一般在#后跟个空格再写文字 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体加粗：文字两边分别用*号包起来 加粗字体 斜体：用一个* 斜体 斜体加粗：三个* 斜体加粗 删除线：用两个～～ 删除线 引用在引用的文字前加&gt;即可，引用也可以嵌套，如加两个&gt;&gt; 这是引用的内容 这是二级引用 分割线三个或者三个以上的-或者*都可以 —或者*** 图片12345![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相等于图片内容的解释图片title是图片的标题，当鼠标移动到图片上时显示的内容，title可加可不加其实最好的方式就是在source/images中放置图片，直接拖过来就可以了。 ![avatar](MarkDown语法/v2-89be8079835866b850f08a2d4583592f_hd.jpg ‘’小昭’’) 超链接1[我的博客](https://guofeiyu.github.io/) 我的博客 列表无序列表可以用-+*任意一种都可以 内容1 内容2 有序列表数字加点 内容列表 内容2 注意:序号和内容之间要有空格 列表嵌套上一级与下一级之间敲三个空格即可 123 张三 李四 代码1`代码内容` 12345(```) 代码... 代码... 代码...(```) 123public static void main(String argos)&#123; System.out.println("hello world");&#125; 流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 行内标记行内标记用反引号把它包起来 纸上得来终觉浅，绝知此事要躬行]]></content>
      <tags>
        <tag>MarkDown语法练习</tag>
      </tags>
  </entry>
</search>
