<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Stream流&Lambda表达式]]></title>
    <url>%2F2019%2F07%2F12%2FStream%E6%B5%81-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[​ Lambda&amp;Stream流 Lambda表达式Lambda表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为Lambda 操作符或剪头操作符。它将 Lambda 分为 两个部分： 左侧： 指定了 Lambda 表达式需要的所有参数。 右侧： 指定了 Lambda 体，即 Lambda 表达式要执行的功能。 （1）语法格式一：无参，无返回值，Lambda 体只需一条语句。 示例： 1Runnable r1 = () -&gt; System.out.println("Hello Lambda!"); （2）语法格式二：Lambda 需要一个参数 。 示例： 1Consumer&lt;String&gt; con = （x） -&gt; System.out.println(x); （3）语法格式三：Lambda 只需要一个参数时，参数的小括号可以省略 。 示例： 1Consumer&lt;String&gt; con = x -&gt; System.out.println(x); （4）语法格式四：Lambda 需要两个参数，并且有返回值 。 示例： 1234567Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println("函数式接口"); return Integer.compare(x, y); &#125;; （5）语法格式五：当 Lambda 体只有一条语句时，return 与大括号可以省略 。 示例： 1Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); （6）Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”。 Lambda 表达式中的参数类型都是由编译器推断得出的。 Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。 Lambda 表达式的类型依赖于上 下文环境，是由编译器推断出来的。这就是所谓的 “类型推断”。 示例： 1234567Comparator&lt;Integer&gt; com = (Integer x,Integer y) -&gt; &#123; //Integer 类型可以省略 System.out.println("函数式接口"); return Integer.compare(x, y); &#125;; Demo123456List&lt;Person&gt; list = Arrays.asList( new Person("aa", 28, "female"), new Person("bb", 22, "male"), new Person("cc", 35, "female"), new Person("dd", 27, "male") ); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * list的排序(匿名内部类) */ @Test public void test() &#123; Collections.sort(list, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person p1, Person p2) &#123; return p1.getAge() - p2.getAge(); &#125; &#125;); list.stream().forEach(System.out::println); &#125; /** * list排序(Lamda表达式) */ @Test public void test0() &#123; Collections.sort(list, (p1, p2) -&gt; p1.getAge() - p2.getAge()); list.stream().forEach(System.out::println); &#125; // Lamda表达式 /** * 无参无返回值 */ @Test public void test1() &#123; MyInterface1 myInterface1 = () -&gt; System.out.println((int) (Math.random() * 1000)); myInterface1.func(); &#125; @Test public void test2() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello World"); &#125; &#125;).start(); &#125; @Test public void test21() &#123; new Thread(() -&gt; System.out.println("Hello World")).start(); &#125; /** * 有一个参数，且无返回值 */ @Test public void test3() &#123; Consumer&lt;String&gt; con = (s) -&gt; System.out.println(s); con.accept("Hello World"); &#125; /** * 有多个参数，括号不能省略,参数类型可以省略，只有一条语句，return和&#123;&#125;可以省略 */ @Test public void test4() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 5, 32, 55, 22, 88); list.sort((Integer x, Integer y) -&gt; x - y); list.sort((x, y) -&gt; x - y); System.out.println(list); &#125; /** * 有多个参数，并且有多条语句 */ @Test public void test5() &#123; list.sort((p1, p2) -&gt; &#123; System.out.println("函数式接口"); return Integer.compare(p1.getAge(), p2.getAge()); &#125;); list.stream().forEach(System.out::println); &#125; Stream流 流，是一系列数据项，它不是一种数据结构。 流可以进行相关的算法和计算，只是它并没有显式地表现，而是在内部进行隐式地操作。 Stream 自己不会存储元素 Stream 不会改变源对象，它会返回一个持有结果的新的Stream Stream 操作是延迟执行的，它们会等到需要结果的时候才执行 12345678910List&lt;Person&gt; list = Arrays.asList( new Person("aaa", 23, "male"), new Person("bbb", 24, "female"), new Person("ccc", 29, "male"), new Person("aaa", 29, "male"), new Person("ddd", 32, "female"), new Person("eee", 29, "male"), new Person("fff", 27, "female"), new Person("fff", 27, "female") ); 1234567891011121314151617181920212223242526/** * 获取流 */ @Test public void test1() &#123; // 通过Collection系列的stream()或parallelStream()方法获取 Stream&lt;Person&gt; stream1 = list.stream(); // 通过Arrays中的静态方法stream()获取数组流 Person[] persons = new Person[10]; Stream&lt;Person&gt; stream2 = Arrays.stream(persons); // 通过Stream中的静态方法of() Stream&lt;String&gt; stream3 = Stream.of("hello", "world"); // 无限流 //迭代 Stream&lt;Integer&gt; stream4 = Stream.iterate(0, x -&gt; x + 10); stream4.limit(10).forEach(System.out::println); // 生成 Stream&lt;Double&gt; stream5 = Stream.generate(() -&gt; Math.random()); stream5.limit(10).forEach(System.out::println); &#125; 基本操作 filter 对流中的元素进行筛选 limit 切断流，使其元素不超过给定的数量 skip 跳过元素，返回一个跳过指定元素的流，若流中元素不足，返回一个空流 distinct 通过流所生成元素的hashCode()和equals()去除重复元素 map 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被引用到每个元素上，并将其映射到一个新的元素 flatMap 将流中的每个值都转换成另一个流，然后把所有流连接成一个流 sorted() 排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Test public void test2() &#123; list.stream().filter(person -&gt; person.getAge() &gt; 28).forEach(System.out::println); &#125; @Test public void test3() &#123; list.stream().limit(2).forEach(System.out::println); &#125; @Test public void test4() &#123; list.stream().skip(2).forEach(System.out::println); &#125; @Test public void test5() &#123; list.stream().distinct().forEach(System.out::println);//重写equals和hashCode方法 &#125; @Test public void test6() &#123; list.stream().map(Person::getName).forEach(System.out::println); &#125; @Test public void test7() &#123; Stream&lt;Stream&lt;Character&gt;&gt; sm = list.stream().map(Person::getName).map(TestStream::filterCharacter); sm.forEach(characterStream -&gt; characterStream.forEach(System.out::println)); //flatMap list.stream().map(Person::getName).flatMap(TestStream::filterCharacter).forEach(System.out::println);// 将多个流转换成一个流 &#125; public static Stream&lt;Character&gt; filterCharacter(String str) &#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character c : str.toCharArray()) &#123; list.add(c); &#125; return list.stream(); &#125; @Test public void test8() &#123; List&lt;Integer&gt; newList = Arrays.asList(5, 3, 7, 1, 8); newList.stream().sorted().forEach(System.out::println); //自然排序 &#125; @Test public void test9() &#123; list.stream().sorted((p1, p2) -&gt; &#123; if (p1.getAge() == p2.getAge()) &#123; return p1.getName().compareTo(p2.getName()); &#125; return Integer.compare(p1.getAge(), p2.getAge()); &#125; ).forEach(System.out::println);//自定义排序 &#125; 查找与匹配 allMatch 查询是否匹配所有元素 anyMatch 检查是否匹配一个元素 noneMatch 检查是否没有匹配所有元素,判断条件里的元素，所有的都不是 findFirst 返回第一个元素 findAny 返回当前流中的任意一个元素 count 计算流中元素的总个数 max 返回流中的最大值 min 返回流中的最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Test public void test10() &#123; boolean b = list.stream().allMatch(person -&gt; person.getAge() &gt; 18); System.out.println(b); &#125; @Test public void test11() &#123; boolean b = list.stream().anyMatch(person -&gt; person.getAge() == 29); System.out.println(b); &#125; @Test public void test12() &#123; boolean b = list.stream().noneMatch(person -&gt; person.getAge() &lt; 18); System.out.println(b); &#125; @Test public void test13() &#123; Optional&lt;Integer&gt; first = list.stream().map(Person::getAge).findFirst(); System.out.println(first.get()); &#125; @Test public void test14() &#123; for (int i = 0; i &lt; 20; i++) &#123; Optional&lt;Person&gt; any = list.stream().findAny();//串行流默认取第一个 System.out.println(any.get()); &#125; System.out.println("============================"); for (int i = 0; i &lt; 20; i++) &#123; Optional&lt;Person&gt; any = list.parallelStream().findAny();//并行流取任意 System.out.println(any.get()); &#125; &#125; @Test public void test15() &#123; long count = list.stream().filter(person -&gt; person.getAge()&gt;25).count(); System.out.println(count); &#125; @Test public void test16() &#123; Optional&lt;Person&gt; max = list.stream().max((p1, p2) -&gt; p1.getAge().compareTo(p2.getAge())); System.out.println(max.get()); &#125; @Test public void test17() &#123; Optional&lt;Person&gt; min = list.stream().min((p1, p2) -&gt; p1.getAge().compareTo(p2.getAge())); System.out.println(min.get()); &#125; reduce 归约 将流中的元素反复结合起来，得到一个值 12345@Testpublic void test18() &#123; Optional&lt;Integer&gt; reduce = list.stream().map(Person::getAge).reduce(Integer::sum); System.out.println(reduce.get());&#125; Collect 收集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Test public void test19() &#123; List&lt;String&gt; stringList = list.stream().map(Person::getName).sorted((s1, s2) -&gt; s2.compareTo(s1)).collect(Collectors.toList()); stringList.forEach(System.out::println); &#125; @Test public void test20() &#123; LinkedList&lt;String&gt; linkedList = list.stream().map(Person::getName).sorted((s1, s2) -&gt; s2.compareTo(s1)).collect(Collectors.toCollection(LinkedList::new)); linkedList.forEach(System.out::println); &#125; @Test public void test21() &#123; HashSet&lt;String&gt; hs = list.stream().map(Person::getName).collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println); &#125; // 平均值 @Test public void test22() &#123; Double collect = list.stream().collect(Collectors.averagingDouble(Person::getAge)); System.out.println(collect); &#125; //最大值 @Test public void test23() &#123; Optional&lt;Integer&gt; optional = list.stream().map(Person::getAge).collect(Collectors.maxBy((x, y) -&gt; x - y)); System.out.println(optional.get()); &#125; //最小值 @Test public void test24() &#123; Optional&lt;Person&gt; optional = list.stream().collect(Collectors.minBy((p1, p2) -&gt; p1.getAge() - p2.getAge())); System.out.println(optional.get()); &#125; //总数 @Test public void test25() &#123; Long collect = list.stream().collect(Collectors.counting()); System.out.println(collect); &#125; // 总和 @Test public void test26() &#123; Integer collect = list.stream().collect(Collectors.summingInt(Person::getAge)); System.out.println(collect); &#125; // 分组 @Test public void test27() &#123; Map&lt;String, List&lt;Person&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Person::getGender)); for (String s : map.keySet()) &#123; System.out.println("===&gt; "+s); map.get(s).stream().forEach(System.out::println); &#125; &#125; // 拼接 @Test public void test28() &#123; String str = list.stream().map(Person::getName).collect(Collectors.joining(",","===","***")); System.out.println(str); &#125; 并行流&amp;串行流对比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 @Test public void test1() &#123; List&lt;Person&gt; bigList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; Person person = new Person("aaa" + i, (20 + i / 10) % 10 + 20, "female"); if (i % 2 == 0) &#123; person.setGender("male"); &#125; bigList.add(person); &#125; Instant start = Instant.now(); for (Person person : bigList) &#123; personDao.save(person); &#125; Instant end = Instant.now(); long time = end.toEpochMilli() - start.toEpochMilli(); System.out.println("耗时：" + time); &#125; //串行流 @Test public void test2() &#123; List&lt;Person&gt; bigList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; Person person = new Person("aaa" + i, (20 + i / 10) % 10 + 20, "female"); if (i % 2 == 0) &#123; person.setGender("male"); &#125; bigList.add(person); &#125; Instant start = Instant.now().plusMillis(TimeUnit.HOURS.toMillis(8)); bigList.stream().forEach(person -&gt; personDao.save(person)); Instant end = Instant.now().plusMillis(TimeUnit.HOURS.toMillis(8)); long time = end.toEpochMilli() - start.toEpochMilli(); System.out.println("耗时：" + time); &#125; //并行流 @Test public void test3() &#123; List&lt;Person&gt; bigList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; Person person = new Person("aaa" + i, (20 + i / 10) % 10 + 20, "female"); if (i % 2 == 0) &#123; person.setGender("male"); &#125; bigList.add(person); &#125; Instant start = Instant.now(); bigList.parallelStream().forEach(person -&gt; personDao.save(person)); Instant end = Instant.now(); long time = end.toEpochMilli() - start.toEpochMilli(); System.out.println("耗时：" + time); &#125; private static List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); private static List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); private static List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); private static Lock lock = new ReentrantLock(); @Test public void test8() &#123; IntStream.range(0, 10000).forEach(list1::add); IntStream.range(0, 10000).parallel().forEach(list2::add); IntStream.range(0, 10000).forEach(i -&gt; &#123; lock.lock(); try &#123; list3.add(i); &#125; finally &#123; lock.unlock(); &#125; &#125;); System.out.println("串行执行的大小：" + list1.size()); System.out.println("并行执行的大小：" + list2.size()); System.out.println("加锁并行执行的大小：" + list3.size()); &#125; @Test public void test9() &#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); IntStream.range(0, 10000).parallel().forEach(vector::add); IntStream.range(0, 10000).parallel().forEach(arrayList::add); System.out.println(vector.size()); System.out.println(arrayList.size()); &#125; @Test public void test10() &#123; //创建集合大小为100 List&lt;Integer&gt; integers = Lists.newArrayList(); for (int i = 0; i &lt; 100; i++) &#123; integers.add(i); &#125;//多管道遍历 List&lt;Integer&gt; integerList = Lists.newArrayList(); integers.parallelStream().forEach(e -&gt; &#123; //添加list的方法 setInteger(integerList, e); try &#123; //休眠100ms Thread.sleep(100); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125;); System.out.println(integerList.size()); &#125; private static void setInteger(List&lt;Integer&gt; integerList, Integer e) &#123; integerList.add(e); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F07%2F12%2FNginx%2F</url>
    <content type="text"><![CDATA[​ 代理模式 ​ 官网 代理模式正向代理如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！ 上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。 正向代理：”它代理的是客户端，代客户端发出请求” 正向代理的用途：（1）访问原来无法访问的资源，如Google（2） 可以做缓存，加速访问资源（3）对客户端访问授权，上网进行认证（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理当每天同时连接到网站的访问人数过多，单个服务器远远不能满足。分布式部署，也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的。 通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。 客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 反向代理，”它代理的是服务端，代服务端接收请求“，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 反向代理的作用：（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网（2）负载均衡，通过反向代理服务器来优化网站的负载 项目场景通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下： 二者区别 在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息； 在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息； 负载均衡客户端发送的请求，Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。 请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。 所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。 Nginx支持的负载均衡调度算法方式如下： weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。 ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。 fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。 url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F07%2F11%2FDocker%2F</url>
    <content type="text"><![CDATA[​ Docker Mysql安装 ​ 官网 DockerDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 Docker 的优点 1、简化程序：Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。 2、避免选择恐惧症：如果你有选择恐惧症，还是资深患者。那么你可以使用 Docker 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。 3、节省开支：一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 容器和虚拟机。 可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。 我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。 而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。 容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。 Docker安装（亲测）1、Docker要求CentOS系统的内核版本高于 3.10 ，通过 uname -r 命令查看你当前的内核版本是否支持安账docker 2、更新yum包：sudo yum update 3、安装需要的软件包，yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 4、设置yum源： ​ sudo yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo 5、可以查看所有仓库中所有docker版本，并选择特定版本安装： ​ yum list docker-ce –showduplicates | sort -r 6、安装docker：sudo yum install docker-ce-17.12.0.ce 7、启动、设置开启开机启动 sudo systemctl start docker sudo systemctl enable docker 8、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)：docker version 9、查看docker启动状态：systemctl status docker（如下图即启动成功) 卸载： 1、查询docker安装过的包： yum list installed | grep docker ​ 2、删除安装包： yum remove docker-ce.x86_64 ddocker-ce-cli.x86_64 -y 3、删除镜像/容器等 rm -rf /var/lib/docker 1234567891011启动 systemctl start docker守护进程重启 sudo systemctl daemon-reload重启docker服务 systemctl restart docker重启docker服务 sudo service docker restart关闭docker service docker stop 关闭docker systemctl stop docker Docker 安装 MySQL1.查找Docker Hub上的mysql镜像1docker search mysql 2.拉取官方镜像1docker pull mysql:5.6 等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.6的镜像 1docker images |grep mysql 3.运行容器1docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 命令说明： -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。 -v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 4.查看容器启动情况1docker ps 12CONTAINER ID IMAGE COMMAND ... PORTS NAMES21cb89213c93 mysql:5.6 &quot;docker-entrypoint.sh&quot; ... 0.0.0.0:3306-&gt;3306/tcp mymysql]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis代码生成器]]></title>
    <url>%2F2019%2F07%2F11%2FMybatis%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[​ 代码生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void generate(String tableName) &#123; // 全局配置 GlobalConfig config = new GlobalConfig(); config/*.setActiveRecord(true)*/ //是否支持AR模式 .setOutputDir(System.getProperty("user.dir") + "/src/main/java")//生成路径 .setFileOverride(true)//设置文件覆盖 .setAuthor("admin") .setIdType(IdType.AUTO)//主键策略 .setServiceName("%sService")//接口名称不带I .setOpen(false) .setBaseResultMap(true) .setBaseColumnList(true); // 配置数据源 DataSourceConfig dsc = new DataSourceConfig(); dsc.setDriverName("com.mysql.jdbc.Driver"); dsc.setUrl("jdbc:mysql://rm-bp16885t0yn5g56gybo.mysql.rds.aliyuncs.com:3306/hotel?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC"); dsc.setUsername("root"); dsc.setPassword("Deeptest2018"); // 策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true)//全局大写命名 .setColumnNaming(NamingStrategy.underline_to_camel) .setNaming(NamingStrategy.underline_to_camel)//数据库表映射到实体的命名策略// .setTablePrefix("tb_")// .setInclude("person");//生成的表 .setInclude(tableName);//生成的表 //包名映射策略 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent("com.hm.hotel_management") .setMapper("dao") .setXml("dao") .setService("service") .setController("controller") .setEntity("entity"); //自动生成 AutoGenerator autoGenerator = new AutoGenerator(); autoGenerator.setGlobalConfig(config) .setDataSource(dsc) .setStrategy(strategyConfig) .setPackageInfo(packageConfig); autoGenerator.execute(); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 排序算法 冒泡排序冒泡排序基本概念是： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续， 直至比较最后两个数，将小数放前，大数放后。至此第一趟结束， 将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数）， 将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的）， 第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 1234567891011public class BubbleSort &#123; public static void sort(int[] data) &#123; for (int i = 0; i &lt; data.length - 1; i++) &#123; for (int j = 0; j &lt; data.length - 1 - i; j++) &#123; if (data[j] &gt; data[j + 1]) &#123; SortTest.swap(data, j, j + 1); &#125; &#125; &#125; &#125;&#125; 插入排序 插入排序基本思想 将n个元素的数列分为已有序和无序两个部分 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较， 找出插入位置，将该元素插入到有序数列的合适位置中。 123456789public class InsertSort &#123; public static void sort(int[] data) &#123; for (int i = 1; i &lt; data.length; i++) &#123; for (int j = i; (j &gt; 0) &amp;&amp; (data[j] &lt; data[j - 1]); j--) &#123; SortTest.swap(data, j, j - 1); &#125; &#125; &#125;&#125; 快速排序快速排序： 一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索（j=j-1即j–）， 找到第一个小于key的值A[j]，A[i]与A[j]交换； 4）从i开始向后搜索，即由前开始向后搜索（i=i+1即i++）， 找到第一个大于key的A[i]，A[i]与A[j]交换； 5）重复第3、4、5步，直到 I=J； (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。 找到并交换的时候i， j指针位置不变。 另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。 12345678910111213141516171819202122232425262728293031323334353637public class QuickSort &#123; public static void sort(int[] data) &#123; quickSort(data, 0, data.length - 1); &#125; private static void quickSort(int[] data, int i, int j) &#123; int pivotIndex = (i + j) / 2; // swap SortTest.swap(data, pivotIndex, j); int k = partition(data, i - 1, j, data[j]); SortTest.swap(data, k, j); if ((k - i) &gt; 1) quickSort(data, i, k - 1); if ((j - k) &gt; 1) quickSort(data, k + 1, j); &#125; /** * @param data * @param i * @param j * @return */ private static int partition(int[] data, int l, int r, int pivot) &#123; do &#123; while (data[++l] &lt; pivot) ; while ((r != 0) &amp;&amp; data[--r] &gt; pivot) ; SortTest.swap(data, l, r); &#125; while (l &lt; r); SortTest.swap(data, l, r); return l; &#125;&#125; 选择排序 选择排序基本思路： 把第一个元素依次和后面的所有元素进行比较。 第一次结束后，就会有最小值出现在最前面。 依次类推 1234567891011public class SelectionSort &#123; public static void sort(int[] data) &#123; for (int x = 0; x &lt; data.length - 1; x++) &#123; for (int y = x + 1; y &lt; data.length; y++) &#123; if (data[y] &lt; data[x]) &#123; SortTest.swap(data, x, y); &#125; &#125; &#125; &#125;&#125; 希尔排序希尔排序：先取一个小于n的整数d1作为第一个增量， 把文件的全部记录分成（n除以d1）个组。所有距离为d1的倍数的记录放在同一个组中。 先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序， 直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。 ***属于插入类排序**,是将整个无序列分割成若干小的子序列分别进行插入排序* * *排序过程：先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，* * *组内进行直接插入排序；然后取d2&lt;d1，重复上述分组和排序操作；直至di=1， 即所有记录放进一个组中排序为止* * *初始：d=5 49 38 65 97 76 13 27 49 55 04* * *49 13 |-------------------|* * *38 27 |-------------------|* * *65 49 |-------------------|* * *97 55 |-------------------|* * *76 04 |-------------------|* * *一趟结果 13 27 49 55 04 49 38 65 97 76* * *d=3 13 27 49 55 04 49 38 65 97 76* * *13 55 38 76 |------------|------------|------------|* * *27 04 65 |------------|------------|* * *49 49 97 |------------|------------|* * *二趟结果 13 04 49* 38 27 49 55 65 97 76* * *d=1 13 04 49 38 27 49 55 65 97 76* * *|----|----|----|----|----|----|----|----|----| 三趟结果* * *04 13 27 38 49 49 55 65 76 97*1234567891011121314151617181920212223public class ShellSort &#123; public static void sort(int[] data) &#123; for (int i = data.length / 2; i &gt; 2; i /= 2) &#123; for (int j = 0; j &lt; i; j++) &#123; insertSort(data, j, i); &#125; &#125; insertSort(data, 0, 1); &#125; /** * @param data * @param j * @param i */ private static void insertSort(int[] data, int start, int inc) &#123; for (int i = start + inc; i &lt; data.length; i += inc) &#123; for (int j = i; (j &gt;= inc) &amp;&amp; (data[j] &lt; data[j - inc]); j -= inc) &#123; SortTest.swap(data, j, j - inc); &#125; &#125; &#125;&#125; 堆排序堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 （1）用大根堆排序的基本思想 ① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 ② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个 记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]， 且满足R[1..n-1].keys≤R[n].key ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。 然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换， 由此得到新的无序区R[1..n-2]和有序区R[n-1..n]， 且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 直到无序区只有一个元素为止。 （2）大根堆排序算法的基本操作： ① 初始化操作：将R[1..n]构造为初始堆； ② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换， 然后将新的无序区调整为堆（亦称重建堆）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HeapSort &#123; public static void sort(int[] data) &#123; MaxHeap h = new MaxHeap(); h.init(data); for (int i = 0; i &lt; data.length; i++) h.remove(); System.arraycopy(h.queue, 1, data, 0, data.length); &#125; private static class MaxHeap &#123; void init(int[] data) &#123; this.queue = new int[data.length + 1]; for (int i = 0; i &lt; data.length; i++) &#123; queue[++size] = data[i]; fixUp(size); &#125; &#125; private int size = 0; private int[] queue; public int get() &#123; return queue[1]; &#125; public void remove() &#123; SortTest.swap(queue, 1, size--); fixDown(1); &#125; // fixdown private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size) &#123; if (j &lt; size &amp;&amp; queue[j] &lt; queue[j + 1]) j++; if (queue[k] &gt; queue[j]) // 不用交换 break; SortTest.swap(queue, j, k); k = j; &#125; &#125; private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j] &gt; queue[k]) break; SortTest.swap(queue, j, k); k = j; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[kafka环境搭建]]></title>
    <url>%2F2019%2F07%2F10%2Fkafka%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[​ Kafka环境搭建 ​ 官网 Zookeeper首先要在Linux系统下安装java环境 1.下载zookeeper到zookeeper官网下载 2.配置zookeeper·利用Xftp将压缩包上传至Linux系统中，解压tar -zxvf zookeeper-3.4.13.tar.gz ·进入conf目录：cd zookeeper-3.4.13/conf ·将zoo_sample.cfg这个文件复制为zoo.cfg (必须是这个文件名cp zoo_sample.cfg zoo.cfg 3.启动zookeeper·进入bin目录，并启动zookeeper 注意： ./zkServer.sh start前面的.不可忽略。 cd/zookeeper-3.4.13/bin ./zkServer.sh start ·启动成功效果如下： ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg Starting zookeeper … STARTED Kafka1. Kafka下载官网下载 2. Kafka配置·利用Xftp将压缩包上传至Linux系统中，解压​ tar -zxvf kafka_2.12-2.3.0 ·配置Kafka文件（不配置也能在本地机上执行，不配置默认主机是localhost ，后期写linux的ip地址） ·启动Kafkacd进入Kafka解压目录，输入 bin/kafka-server-start.sh config/server.properties 3. Producer和Counsumer·创建一个topic在Kafka解压目录打开终端，输入 bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test 创建一个名为test的topic 在创建topic后可以通过输入 bin/kafka-topics.sh –list –zookeeper localhost:2181 来查看已经创建的topic ·创建一个消息消费者（Counsumer）在Kafka解压目录打开终端，输入 bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning 可以创建一个用于消费topic为test的消费者 消费者创建完成之后，因为还没有发送任何数据，这里在执行后没有打印出任何数据 ·创建一个消息生产者（Producer）在Kafka解压目录打开一个新的终端，输入 bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test 在执行完毕后会进入的编辑器页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[雪花算法]]></title>
    <url>%2F2019%2F07%2F10%2F%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ snowflake 雪花算法简单描述： 最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 看的出来，这个算法很简洁也很简单，但依旧是一个很好的ID生成策略。其中，10位器标识符一般是5位IDC+5位machine编号，唯一确定一台机器。 Snowflake算法核心把时间戳，工作机器id，序列号组合在一起。 整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 Twitter的 Snowflake JAVA实现方案 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用： 1||0—0000000000 0000000000 0000000000 0000000000 0 — 00000 —00000 —000000000000 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间， 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识）， 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface; public class IdWorker &#123; // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker()&#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** - @param workerId - 工作机器ID - @param datacenterId - 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** - 获取下一个ID * - @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** - &lt;p&gt; - 获取 maxWorkerId - &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* - GET jvmPid */ mpid.append(name.split("@")[0]); &#125; /* - MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** - &lt;p&gt; - 数据标识id部分 - &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(" getDatacenterId: " + e.getMessage()); &#125; return id; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2019%2F06%2F02%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ Markdown的语法 ​ 语法文档 字体颜色，大小设置12345678&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=72 face=”黑体”color=#00ffffcolor=gray Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 颜色表 设置图片展示比例1&lt;img src="快捷键/wallhaven-374651123.png" width="50%" height="50%"&gt; Next主题的内置标签文本居中的引用 此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。 12345&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 效果弱者只有千难万难，而勇者则能披荆斩棘;愚者只有声声哀叹，智者却有千路万路。 一帆风顺的人，往往经受不住挫折。 凡事要主动出击你才能成为主角，否则你只能是配角! Bootstrap Callout使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger 效果从上到下 一切利己的生活，都是非理性的，动物的生活。——列夫·托尔斯泰 受苦的人，没有悲观的权利。——尼采 越学习，越发现自己的无知。——笛卡尔 社会是一个泥坑，我们得站在高地上。——巴尔扎克 生命不等于是呼吸，生命是活动。——卢梭 人生不是一种享乐，而是一桩十分沉重的工作。——列夫·托尔斯泰 标题标准语法一般在#后跟个空格再写文字 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体加粗：文字两边分别用*号包起来 加粗字体 斜体：用一个* 斜体 斜体加粗：三个* 斜体加粗 删除线：用两个～～ 删除线 引用在引用的文字前加&gt;即可，引用也可以嵌套，如加两个&gt;&gt; 这是引用的内容 这是二级引用 分割线三个或者三个以上的-或者*都可以 —或者*** 图片12345![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相等于图片内容的解释图片title是图片的标题，当鼠标移动到图片上时显示的内容，title可加可不加其实最好的方式就是在source/images中放置图片，直接拖过来就可以了。 ![avatar](MarkDown语法/v2-89be8079835866b850f08a2d4583592f_hd.jpg ‘’小昭’’) 超链接1[我的博客](https://guofeiyu.github.io/) 我的博客 列表无序列表可以用-+*任意一种都可以 内容1 内容2 有序列表数字加点 内容列表 内容2 注意:序号和内容之间要有空格 列表嵌套上一级与下一级之间敲三个空格即可 123 张三 李四 代码1`代码内容` 12345(```) 代码... 代码... 代码...(```) 123public static void main(String argos)&#123; System.out.println("hello world");&#125; 流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 行内标记行内标记用反引号把它包起来 纸上得来终觉浅，绝知此事要躬行]]></content>
      <tags>
        <tag>MarkDown语法练习</tag>
      </tags>
  </entry>
</search>
