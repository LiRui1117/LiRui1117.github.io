<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ 排序算法 冒泡排序冒泡排序基本概念是： 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续， 直至比较最后两个数，将小数放前，大数放后。至此第一趟结束， 将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数）， 将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的）， 第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 1234567891011public class BubbleSort &#123; public static void sort(int[] data) &#123; for (int i = 0; i &lt; data.length - 1; i++) &#123; for (int j = 0; j &lt; data.length - 1 - i; j++) &#123; if (data[j] &gt; data[j + 1]) &#123; SortTest.swap(data, j, j + 1); &#125; &#125; &#125; &#125;&#125; 插入排序 插入排序基本思想 将n个元素的数列分为已有序和无序两个部分 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较， 找出插入位置，将该元素插入到有序数列的合适位置中。 123456789public class InsertSort &#123; public static void sort(int[] data) &#123; for (int i = 1; i &lt; data.length; i++) &#123; for (int j = i; (j &gt; 0) &amp;&amp; (data[j] &lt; data[j - 1]); j--) &#123; SortTest.swap(data, j, j - 1); &#125; &#125; &#125;&#125; 快速排序快速排序： 一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索（j=j-1即j–）， 找到第一个小于key的值A[j]，A[i]与A[j]交换； 4）从i开始向后搜索，即由前开始向后搜索（i=i+1即i++）， 找到第一个大于key的A[i]，A[i]与A[j]交换； 5）重复第3、4、5步，直到 I=J； (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。 找到并交换的时候i， j指针位置不变。 另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。 12345678910111213141516171819202122232425262728293031323334353637public class QuickSort &#123; public static void sort(int[] data) &#123; quickSort(data, 0, data.length - 1); &#125; private static void quickSort(int[] data, int i, int j) &#123; int pivotIndex = (i + j) / 2; // swap SortTest.swap(data, pivotIndex, j); int k = partition(data, i - 1, j, data[j]); SortTest.swap(data, k, j); if ((k - i) &gt; 1) quickSort(data, i, k - 1); if ((j - k) &gt; 1) quickSort(data, k + 1, j); &#125; /** * @param data * @param i * @param j * @return */ private static int partition(int[] data, int l, int r, int pivot) &#123; do &#123; while (data[++l] &lt; pivot) ; while ((r != 0) &amp;&amp; data[--r] &gt; pivot) ; SortTest.swap(data, l, r); &#125; while (l &lt; r); SortTest.swap(data, l, r); return l; &#125;&#125; 选择排序 选择排序基本思路： 把第一个元素依次和后面的所有元素进行比较。 第一次结束后，就会有最小值出现在最前面。 依次类推 1234567891011public class SelectionSort &#123; public static void sort(int[] data) &#123; for (int x = 0; x &lt; data.length - 1; x++) &#123; for (int y = x + 1; y &lt; data.length; y++) &#123; if (data[y] &lt; data[x]) &#123; SortTest.swap(data, x, y); &#125; &#125; &#125; &#125;&#125; 希尔排序希尔排序：先取一个小于n的整数d1作为第一个增量， 把文件的全部记录分成（n除以d1）个组。所有距离为d1的倍数的记录放在同一个组中。 先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序， 直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。 ***属于插入类排序**,是将整个无序列分割成若干小的子序列分别进行插入排序* * *排序过程：先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，* * *组内进行直接插入排序；然后取d2&lt;d1，重复上述分组和排序操作；直至di=1， 即所有记录放进一个组中排序为止* * *初始：d=5 49 38 65 97 76 13 27 49 55 04* * *49 13 |-------------------|* * *38 27 |-------------------|* * *65 49 |-------------------|* * *97 55 |-------------------|* * *76 04 |-------------------|* * *一趟结果 13 27 49 55 04 49 38 65 97 76* * *d=3 13 27 49 55 04 49 38 65 97 76* * *13 55 38 76 |------------|------------|------------|* * *27 04 65 |------------|------------|* * *49 49 97 |------------|------------|* * *二趟结果 13 04 49* 38 27 49 55 65 97 76* * *d=1 13 04 49 38 27 49 55 65 97 76* * *|----|----|----|----|----|----|----|----|----| 三趟结果* * *04 13 27 38 49 49 55 65 76 97*1234567891011121314151617181920212223public class ShellSort &#123; public static void sort(int[] data) &#123; for (int i = data.length / 2; i &gt; 2; i /= 2) &#123; for (int j = 0; j &lt; i; j++) &#123; insertSort(data, j, i); &#125; &#125; insertSort(data, 0, 1); &#125; /** * @param data * @param j * @param i */ private static void insertSort(int[] data, int start, int inc) &#123; for (int i = start + inc; i &lt; data.length; i += inc) &#123; for (int j = i; (j &gt;= inc) &amp;&amp; (data[j] &lt; data[j - inc]); j -= inc) &#123; SortTest.swap(data, j, j - inc); &#125; &#125; &#125;&#125; 堆排序堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 （1）用大根堆排序的基本思想 ① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 ② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个 记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]， 且满足R[1..n-1].keys≤R[n].key ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。 然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换， 由此得到新的无序区R[1..n-2]和有序区R[n-1..n]， 且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 直到无序区只有一个元素为止。 （2）大根堆排序算法的基本操作： ① 初始化操作：将R[1..n]构造为初始堆； ② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换， 然后将新的无序区调整为堆（亦称重建堆）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HeapSort &#123; public static void sort(int[] data) &#123; MaxHeap h = new MaxHeap(); h.init(data); for (int i = 0; i &lt; data.length; i++) h.remove(); System.arraycopy(h.queue, 1, data, 0, data.length); &#125; private static class MaxHeap &#123; void init(int[] data) &#123; this.queue = new int[data.length + 1]; for (int i = 0; i &lt; data.length; i++) &#123; queue[++size] = data[i]; fixUp(size); &#125; &#125; private int size = 0; private int[] queue; public int get() &#123; return queue[1]; &#125; public void remove() &#123; SortTest.swap(queue, 1, size--); fixDown(1); &#125; // fixdown private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size) &#123; if (j &lt; size &amp;&amp; queue[j] &lt; queue[j + 1]) j++; if (queue[k] &gt; queue[j]) // 不用交换 break; SortTest.swap(queue, j, k); k = j; &#125; &#125; private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j] &gt; queue[k]) break; SortTest.swap(queue, j, k); k = j; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[kafka环境搭建]]></title>
    <url>%2F2019%2F07%2F10%2Fkafka%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[​ Kafka环境搭建 ​ 官网 Zookeeper首先要在Linux系统下安装java环境 1.下载zookeeper到zookeeper官网下载 2.配置zookeeper·利用Xftp将压缩包上传至Linux系统中，解压tar -zxvf zookeeper-3.4.13.tar.gz ·进入conf目录：cd zookeeper-3.4.13/conf ·将zoo_sample.cfg这个文件复制为zoo.cfg (必须是这个文件名cp zoo_sample.cfg zoo.cfg 3.启动zookeeper·进入bin目录，并启动zookeeper 注意： ./zkServer.sh start前面的.不可忽略。 cd/zookeeper-3.4.13/bin ./zkServer.sh start ·启动成功效果如下： ZooKeeper JMX enabled by default Using config: /usr/local/zookeeper-3.4.13/bin/../conf/zoo.cfg Starting zookeeper … STARTED Kafka1. Kafka下载官网下载 2. Kafka配置·利用Xftp将压缩包上传至Linux系统中，解压​ tar -zxvf kafka_2.12-2.3.0 ·配置Kafka文件（不配置也能在本地机上执行，不配置默认主机是localhost ，后期写linux的ip地址） ·启动Kafkacd进入Kafka解压目录，输入 bin/kafka-server-start.sh config/server.properties 3. Producer和Counsumer·创建一个topic在Kafka解压目录打开终端，输入 bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test 创建一个名为test的topic 在创建topic后可以通过输入 bin/kafka-topics.sh –list –zookeeper localhost:2181 来查看已经创建的topic ·创建一个消息消费者（Counsumer）在Kafka解压目录打开终端，输入 bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning 可以创建一个用于消费topic为test的消费者 消费者创建完成之后，因为还没有发送任何数据，这里在执行后没有打印出任何数据 ·创建一个消息生产者（Producer）在Kafka解压目录打开一个新的终端，输入 bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test 在执行完毕后会进入的编辑器页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[雪花算法]]></title>
    <url>%2F2019%2F07%2F10%2F%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ snowflake 雪花算法简单描述： 最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 看的出来，这个算法很简洁也很简单，但依旧是一个很好的ID生成策略。其中，10位器标识符一般是5位IDC+5位machine编号，唯一确定一台机器。 Snowflake算法核心把时间戳，工作机器id，序列号组合在一起。 整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;/**- &lt;p&gt;名称：IdWorker.java&lt;/p&gt;- &lt;p&gt;描述：分布式自增长ID&lt;/p&gt;- &lt;pre&gt;- Twitter的 Snowflake JAVA实现方案- &lt;/pre&gt;- 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用：- 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000- 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，- 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），- 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。- 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），- 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。- &lt;p&gt;- 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) *- @author Polim */ public class IdWorker &#123; // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker()&#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** - @param workerId - 工作机器ID - @param datacenterId - 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** - 获取下一个ID * - @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** - &lt;p&gt; - 获取 maxWorkerId - &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* - GET jvmPid */ mpid.append(name.split("@")[0]); &#125; /* - MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** - &lt;p&gt; - 数据标识id部分 - &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(" getDatacenterId: " + e.getMessage()); &#125; return id; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2019%2F06%2F02%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ Markdown的语法 ​ 语法文档 字体颜色，大小设置12345678&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=72 face=”黑体”color=#00ffffcolor=gray Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 颜色表 设置图片展示比例1&lt;img src="快捷键/wallhaven-374651123.png" width="50%" height="50%"&gt; Next主题的内置标签文本居中的引用 此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。 12345&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 效果弱者只有千难万难，而勇者则能披荆斩棘;愚者只有声声哀叹，智者却有千路万路。 一帆风顺的人，往往经受不住挫折。 凡事要主动出击你才能成为主角，否则你只能是配角! Bootstrap Callout使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger 效果从上到下 一切利己的生活，都是非理性的，动物的生活。——列夫·托尔斯泰 受苦的人，没有悲观的权利。——尼采 越学习，越发现自己的无知。——笛卡尔 社会是一个泥坑，我们得站在高地上。——巴尔扎克 生命不等于是呼吸，生命是活动。——卢梭 人生不是一种享乐，而是一桩十分沉重的工作。——列夫·托尔斯泰 标题标准语法一般在#后跟个空格再写文字 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体加粗：文字两边分别用*号包起来 加粗字体 斜体：用一个* 斜体 斜体加粗：三个* 斜体加粗 删除线：用两个～～ 删除线 引用在引用的文字前加&gt;即可，引用也可以嵌套，如加两个&gt;&gt; 这是引用的内容 这是二级引用 分割线三个或者三个以上的-或者*都可以 —或者*** 图片12345![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相等于图片内容的解释图片title是图片的标题，当鼠标移动到图片上时显示的内容，title可加可不加其实最好的方式就是在source/images中放置图片，直接拖过来就可以了。 ![avatar](MarkDown语法/v2-89be8079835866b850f08a2d4583592f_hd.jpg ‘’小昭’’) 超链接1[我的博客](https://guofeiyu.github.io/) 我的博客 列表无序列表可以用-+*任意一种都可以 内容1 内容2 有序列表数字加点 内容列表 内容2 注意:序号和内容之间要有空格 列表嵌套上一级与下一级之间敲三个空格即可 123 张三 李四 代码1`代码内容` 12345(```) 代码... 代码... 代码...(```) 123public static void main(String argos)&#123; System.out.println("hello world");&#125; 流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 行内标记行内标记用反引号把它包起来 纸上得来终觉浅，绝知此事要躬行]]></content>
      <tags>
        <tag>MarkDown语法练习</tag>
      </tags>
  </entry>
</search>
